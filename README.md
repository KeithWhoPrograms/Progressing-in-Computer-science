# Progressing-in-Computer-science
An enduring chronicle of my growth and progress in varying computer science disciplines.

2/27/21 I was tasked with submitting a project from CS-210, and I honestly couldn't think of one. That in mind, overall, I'm understanding C++ more completely sooner than I was expecting to; and I feel ready to move on to more advanced concepts within the language, along with more advanced applications of what I already know. 

"Where and how could I enhance my code?"
    This is my first assignment through Github, and I know already how quickly a skill set can expand, so I'm actually glad that I can't really say how I might look back on past code, only to say that I look forward to the day that I do come back to those old assignments and feel that they're now quaint compared to what I can do by that point.
   
I found alot of the coding assignments "challenging" early on, with those early lessons and the way "zybooks" presents the material not really being condusive to learning. It wasn't until I went out, on my own and learned in C++ the things that I already know how to do in Basic, from there, things really turned around. Transferable skills, not to boisterous, have to be the things I went out and picked up on my own; any individual program I put in here whether I'm in school or beyond that point, was/will be built on that foundation.

04/21/21 The Gaming Room tasked me with plotting the development and strategy behind how to best port their game "Draw it or Lose it" to other platforms. Specifically, the only software requirement was to maintain the integrity of the base game in it's various potential ports, the game itself, marketed as a sort of reimagined Pictionary, relies on the displaying of a database of high-quality images.

I feel that I was at my best composing the document throughout, wording and presenting things aren't really an issue for me, though I didn't feel familiar enough with some of the potential platforms to be speaking on them, as my school's somewhat hands-off approach to education leaves a good bit to be desired and these concepts are left feeling less than fully explored.

I would say being made to plot out my code or a project's development has helped me visualize what I want to do on a finer level than I anticipated. Furthermore, at this point I wouldn't choose to revise any part of what I've done as I haven't learned anything new or different enough to go about fine tuning it from/with, though I can imagine a time when I could maybe write the code in a more optimized fashion, or maybe even a simpler method of performing the same processes.

From experience I felt that I could intuit the user's experience and that perspective was a factor in my ultimate decision to go with Windows PCs for the port. These days, not many programs are designed to be this "reliant" on images for the gameplay, so I don't believe much could carry over, and to come back to this type of project in the future, I would expect that I could whip that one together even easier because of this experience.

8/22/21 By making sure that this information was first clearly presented to me before then bringing it to the team for inclusion in the application. Since 'user stories' are descriptions from the same person requesting the work, theoretically this approach helps to prevent miscommunication, between the two parties.

I begin the project with all required design materials re-assembled personally from the original materials and the disparate sources that it's compiled from, this way, it's "my" program before I get started, made my way but composed of what someone else has contracted me to produce. When working with a team, scrum meetings feel the most necessary, especially if there is no prior relationship between the team members, it'll help establish a rapport and with that trust, a more effective team.

Communication, a team that can't rely on each other isn't a team, they're a group of individuals who can much more easily fail from trying to take on too much essentially alone.


10/24/21    A man named Liam was the head of a company called DriverPass and he wanted an app developed by that same name that would perform certain functions. While Liam was not particulary computer savvy; he wanted to access all his files through the app with and without internet access for example, he still though, knew what he wanted.

    He wanted a system that would offer a network version of the in-person experience of working with DriverPass; taking tests and scheduling appointments in particular. My design, after gathering the client's list of wants was a minimal framework for accessing the test packages and scheduling revervations. I felt that a simple design would be best, first in principle, but also for the client, whose requests imply a leaner design philosophy.
    
    I brought up their lack of requests, and I would expect that the final design will include some DriverPass graphics/images to dress up the pages of the application. Revise isn't quite the word, I would be "furthering my design", in my mind, I see myself adding .png images and maybe a few videos to the DriverPass framework that I laid down.
    
The client's requirements ARE the program, and I follow their requests to the letter.
    
    Overall, i build programs to the requirements of the design outline. I was already sketching outlines for what I was going to build before this class, I'm originally a self taught programmer, so I will continue to respect my program's requirements and it's outline, also, don't forget to comment your work.  


02/27/22 - This time I was tasked to build a network secure app for a company called Artemis Financial, my portfolio now includes a vulnerability assessment that I prepared for them. They are a banking group that were looking to strengthen their online prescence and secure it with a modern software solution. More and more customers interact with companies through software these days, and it's increasingly important to make sure those paths are secure, since when it isn't those issues can be like potholes in the road between your house and the bank. I'm well accustomed to writing compartmentalized code as it is, because my writing style has been to write favoring sub-routines or in C++, methods. So my code is inherently segmented in ways that dynamically gate off access and support for security measures easily. Whatever the task ends up being, security is the backbone of an app your client and their customers can trust. It was hard to remember every entry of the vulnerability assessment, but it was a good checklist to have.

    I believe that it is always, eventually ineffective to try to anticipate what can't be known, instead trying solely to prepare for an intagiable threat, I say, build something that is inherently secure. Besides the IDE not showing any new errors, then the Maven dependency check looking for further vulnerabilites and finally an OWASP to find anything else that may have been missed, the OWASP is a similar check to the Maven. Finally, the screenshots in the report can demonstrate some of the tools I employ and my prowess with them.

4/24/22 - Running JUnit tests will make certain that I catch the errors in code that aren't flagged in the the IDE. Beyond that, the process would be down to skills and best practices, oh and another test like Junit tests, though it's name I can't quite remember. If users desires aren't stated on some sort of document beforehand, then I would get their needs and desires from them in an interview with them, apart from that, software design is needs based. When I say that, I mean build to perform whatever you need it to do.

8/22/22 - How to keep my code "maintainable, readable, and adaptable"? Well, I first learned to program by writing in Basic, where I grew to understand that you can boil it all down to loops, if/then statements, variables and sub-routines. Attaching functions to buttons makes things but easier and more user-friendly for someone to come along and use your program, with the buttons being more "inviting" than a wall of code.

I approach problems as a computer scientist by breaking them down into digestable chunks; dissecting the work even to the point of solving it section by section. I would be surprised if MongoDb came up in my work outside of a school setting, but the button interface is a very good skill to carry forward. Before this I don't any class really introduced something that unique to take to other projects.

A computer scientist intimately understands software intending to then write better functioning software; these programs automate mundane tasks, improve existing technologies and services and even create whole new jobs and employable skillsets. Like I alluded to, this software would automate or streamline the mundane tasks of their work into a simple, easy to understand new format/dynamic.
